<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Python on nathan leclaire </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://localhost:1313/categories/python/index.xml</link>
    
    
    
    <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>
    
    <item>
      <title>Build a Linked List For Each Layer in a Binary Tree</title>
      <link>http://localhost:1313/_posts/2014-03-01-build-a-linked-list-for-each-layer-in-a-binary-tree</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/_posts/2014-03-01-build-a-linked-list-for-each-layer-in-a-binary-tree</guid>
      <description>

&lt;p&gt;{%img /images/linkedListTree/binary_tree.png %}&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve been going through problems in &lt;a href=&#34;http://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/098478280X&#34;&gt;Cracking the Coding Interview&lt;/a&gt; to keep my chops strong and for giggles and this one took a little bit of wrangling for me to get:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a binary search tree, design an algorithm which creates a linked list of all the
nodes at each depth (i e , if you have a tree with depth D, youâ€™ll have D linked lists)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So a binary tree such as :&lt;/p&gt;

&lt;pre&gt;
       (1)
      /   \
     /     \
   (2)     (3)
  /  \     / \
(4)  (5) (6) (7)
&lt;/pre&gt;

&lt;p&gt;Will return linked lists:&lt;/p&gt;

&lt;pre&gt;
(1) =&gt; NULL
(2) =&gt; (3) =&gt; NULL
(4) =&gt; (5) =&gt; (6) =&gt; (7) =&gt; NULL
&lt;/pre&gt;

&lt;p&gt;I wrote up my solution to this in Python, and I&amp;rsquo;m going to share it with you to study and critique.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Solution&lt;/h1&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;The Linked List Implementation&lt;/h2&gt;

&lt;p&gt;If you&amp;rsquo;ve ever seen or written a linked list implementation before, you&amp;rsquo;ll probably realize there&amp;rsquo;s nothing particularly brilliant or innovative about this one.  Just a good old-fashioned, simple singly linked list.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;class LinkedList:
    next = None
    val = None
 
    def __init__(self, val):
        self.val = val
 
    def add(self, val):
        if self.next == None:
            self.next = LinkedList(val)
        else:
            self.next.add(val)
 
    def __str__(self):
        return &amp;quot;({val}) &amp;quot;.format(val=self.val) + str(self.next)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Usage:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;ll = LinkedList(1)
ll.add(2)
ll.add(3)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;The Binary Tree Implementation&lt;/h2&gt;

&lt;p&gt;The binary tree implementation is similarly from scratch, and simlarly simple.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;class BinaryTree:
    val = None
    left = None
    right = None
    
    def __init__(self, val):
        self.val = val
 
    def __str__(self):
        return &amp;quot;&amp;lt;Binary Tree (val is {val}). \n\tleft is {left} \n\tright is {right}&amp;gt;&amp;quot;.format(val=self.val, left=self.left, right=self.right)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No methods, I do all of the tree manipulation by hand.  This works okay for problems of this (considerably small) scale.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;The Algorithm&lt;/h2&gt;

&lt;p&gt;The algorithm that I came up with is actually slightly different than what is listed as the solution in the book, and depends a bit of idiosyncracies of Python that aren&amp;rsquo;t in Java (which all of the solutions from the book are written in).  Namely, it uses optional arguments to avoid wrapper methods and it uses a dictionary instead of a &lt;code&gt;ArrayList&amp;lt;LinkedList&amp;lt;BinaryTree&amp;gt;&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I also differ from the solution in the book in that I grab the depth of the tree once and use that to determine the linked list&amp;rsquo;s index, which is slightly less efficient than the solution that they provide.  If I&amp;rsquo;m not mistaken, however, the asymptotic complexity is still the same (&lt;code&gt;O(n)&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;My depth function is exactly what you&amp;rsquo;d expect (recursive):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;def depth(tree):
    if tree == None:
        return 0
    if tree.left == None and tree.right == None:
        return 1
    else:
        depthLeft = 1+depth(tree.left)
        depthRight = 1+depth(tree.right)
        if depthLeft &amp;gt; depthRight:
            return depthLeft
        else:
            return depthRight
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;My &lt;code&gt;tree_to_linked_lists&lt;/code&gt; function does a &lt;a href=&#34;http://en.wikipedia.org/wiki/Tree_traversal#Pre-order&#34;&gt;pre-order traversal&lt;/a&gt;, adding nodes to their corresponding linked list (based on depth) in the dictionary &lt;code&gt;lists&lt;/code&gt; as the tree is traversed.  &lt;code&gt;lists&lt;/code&gt; is passed into, and returned from (in its mutated state), each call to &lt;code&gt;tree_to_linked_lists&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;def tree_to_linked_lists(tree, lists={}, d=None):
    if d == None:
        d = depth(tree)
    if lists.get(d) == None:
        lists[d] = LinkedList(tree.val)
    else:
        lists[d].add(tree.val)
        if d == 1:
            return lists
    if tree.left != None:
        lists = tree_to_linked_lists(tree.left, lists, d-1)
    if tree.right != None:
        lists = tree_to_linked_lists(tree.right, lists, d-1)
    return lists
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This produces a result that is sort of in reverse order compared to the solution provided by the book, but it still satisfies the problem description to provide a collection of linked lists.&lt;/p&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;You can find the entirety of the code &lt;a href=&#34;https://gist.github.com/nathanleclaire/9292861&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I need to be better at data structures and algorithms.  They are fun.&lt;/p&gt;

&lt;p&gt;Until next time, stay sassy Internet.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Nathan&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>How I Automated &#34;Finding Almost Anyone&#39;s Email Address&#34;</title>
      <link>http://localhost:1313/_posts/2013-11-23-how-i-automated-finding-almost-anyones-email-address</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/_posts/2013-11-23-how-i-automated-finding-almost-anyones-email-address</guid>
      <description>

&lt;p&gt;{% img /images/autorap/demo-fast.gif A demo, complete with colors. %}&lt;/p&gt;

&lt;p&gt;&lt;em&gt;EDIT:  The original article author, Rob Ousbey, has popped up on various social media sites to remind everyone to use this tool/knowledge responsibly.  I agree.  Please be responsible.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Not too long ago I came across an article on &lt;a href=&#34;https://news.ycombinator.com&#34;&gt;Hacker News&lt;/a&gt; called &amp;ldquo;&lt;a href=&#34;http://www.startupmoon.com/how-i-got-meetings-at-twitter-linkedin-and-github-using-cold-emails/&#34;&gt;The cold emails that got me meetings at Twitter, LinkedIn and GitHub&lt;/a&gt;&amp;rdquo;.  It&amp;rsquo;s by a woman named Iris Shoor who is a co-founder of a startup called &lt;a href=&#34;http://www.takipi.com/&#34;&gt;Takipi&lt;/a&gt;.  In the article she describes how she used a certain technique originally presented &lt;a href=&#34;http://www.distilled.net/blog/miscellaneous/find-almost-anybodys-email-address/&#34;&gt;here&lt;/a&gt; to obtain access to the emails of decision makers at tech companies and cold email them to glean meetings which resulted in sales of her product.  Both of the articles are engaging reads and I highly recommend them, especially if you are interested in &amp;ldquo;growth hacking&amp;rdquo;, or &amp;ldquo;sales and marketing&amp;rdquo; if you insist on using boring non-buzzwords.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;How Does It Work?&lt;/h1&gt;

&lt;p&gt;In the original &amp;ldquo;How To Find Almost Anyone&amp;rsquo;s Email Address&amp;rdquo; article, Rob Ousbey presents a Google Doc spreadsheet that will generate a large number of possible emails for someone based on their name and the domain name of the company they work for.  &lt;a href=&#34;http://bit.ly/name2email&#34;&gt;Go ahead, try it out&lt;/a&gt;.  Many peoples&amp;rsquo; emails are something along the lines of &lt;em&gt;[firstname].[lastname]@[company].com&lt;/em&gt;, so there&amp;rsquo;s a high likelihood that their email will be in the list of generated possibilities.&lt;/p&gt;

&lt;p&gt;Then, users are encouraged to exhaustively test each possibility in their Gmail account using the &lt;a href=&#34;https://rapportive.com/&#34;&gt;Rapportive&lt;/a&gt; Chrome extension until they come across a &amp;lsquo;hit&amp;rsquo; (although a little bit of creative Googling will sometimes yield the desired result for you in less time).&lt;/p&gt;

&lt;p&gt;When trying this out for the first time on a recruiter I was interested in contacting, I found myself clicking the generated permutations in succession with a looming disbelief that this trick would actually work.  Then, suddenly, Rapportive lit up with their portrait and social media info and I felt a funny buzzing sensation in my head as the possibilities swirled around in it.&lt;/p&gt;

&lt;p&gt;{% img /images/autorap/larry.png I feel funny about this. %}&lt;/p&gt;

&lt;p&gt;However, doing it this way was exhausting and tedious, as it required a lot of focus and time.  My programmer instincts revved up and I became convinced that I could automate the process.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Automating It&lt;/h1&gt;

&lt;p&gt;I won&amp;rsquo;t be publishing my full source code because this has so much potential for abuse, but I will talk a little bit here about how I accomplished automating this.  I chose to reach for my old friend Python to write the script to automate this process.  I wanted to get things done quickly and easily and Python proved to be a great boon here, even providing the excellent &lt;code&gt;argparse&lt;/code&gt; module to make the script much more usable from the command line.&lt;/p&gt;

&lt;p&gt;{% img /images/autorap/copy-as-curl.jpeg Useful Developer Tools are useful. %}&lt;/p&gt;

&lt;p&gt;First, I got an example cURL request using Chrome&amp;rsquo;s handy developer tools.&lt;/p&gt;

&lt;p&gt;Then, I called the &amp;ldquo;secret&amp;rdquo; Rapportive API using &lt;code&gt;pycurl&lt;/code&gt;.  There&amp;rsquo;s a few fields that can be used to identify whether a response has come back for the suggested user, and we use that to determine whether the user, and consequently their email address, has been found.  We also check it against the returned full name to ensure that we haven&amp;rsquo;t gotten back a false positive (for example, Rapportive may return something for &amp;ldquo;larry@google.com&amp;rdquo;, but it may not be the Larry we are looking for).  Outputting all of the emails we try to the terminal, we color the bunk addresses red, the &amp;ldquo;false positive&amp;rdquo; emails yellow, and the successful return results green.  Like good Internet citizens, we wait for a specified interval in between calls to the Rapportive server (2 seconds in the demo at the top of this page).  Upon finding the email for the person we&amp;rsquo;re looking for, the program exits.&lt;/p&gt;

&lt;p&gt;The Rapportive API is surprisingly flexible on what you send it as far as HTTP headers goes, seeming to rely mostly on the &lt;code&gt;X-Session-Token&lt;/code&gt; header for user authentication.&lt;/p&gt;

&lt;p&gt;The main loop in Python looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;if __name__ == &#39;__main__&#39;:
    args = argument_handler.handle_args()   
    rap_client = RapportiveClient(args.name, verbose=args.verbose)
    permutator = Permutator(args.name, args.domain) 
    permutations = permutator.get_permutations()

    for permutation in permutations:
        output = permutation 
        rap_client.perform(permutation)
        if args.should_color:
            output = colorer.color(permutation, rap_client)
        if not args.quiet: 
            print output 
            if rap_client.was_user_found() and rap_client.name_match():
                sys.exit(0)
        else:
            if rap_client.was_user_found():
                print output
                sys.exit(0) 
        time.sleep(args.wait_interval)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Rapportive is a subsidiary of LinkedIn and LinkedIn has been catching a lot of heat lately for everything from their &lt;a href=&#34;http://engineering.linkedin.com/mobile/linkedin-intro-doing-impossible-ios&#34;&gt;iOS MITM hack&lt;/a&gt; to their &lt;a href=&#34;http://blog.linkedin.com/2012/06/06/linkedin-member-passwords-compromised/&#34;&gt;notorious password breach&lt;/a&gt;.  They&amp;rsquo;re a popular company to love to hate.  However, I think their tools have as much potential for cool stuff as they do for abuse.  Honestly, I&amp;rsquo;m surprised that the trick described in this article is not more well-known.  I haven&amp;rsquo;t cold emailed anyone whose address I have obtained this way, but if I needed to do so I&amp;rsquo;d be very pleased to have this tool at my disposal.&lt;/p&gt;

&lt;p&gt;Cheers and I&amp;rsquo;ll see you next week.&lt;/p&gt;

&lt;p&gt;Nathan&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>