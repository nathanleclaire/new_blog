<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Email on nathan leclaire </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://localhost:1313/categories/email/index.xml</link>
    
    
    
    <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>
    
    <item>
      <title>Sending Email From Gmail Using Golang</title>
      <link>http://localhost:1313/posts/2013-12-17-sending-email-from-gmail-using-golang</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/posts/2013-12-17-sending-email-from-gmail-using-golang</guid>
      <description>

&lt;p&gt;As part of the soon-to-be-deployed &lt;a href=&#34;http://github.com/nathanleclaire/checkforbrokenlinks&#34;&gt;checkforbrokenlinks&lt;/a&gt; app, I found myself faced with the task of creating a contact form that would allow users to send me feedback on the app, so I could improve it and make it better in the future.  In order to do so I had to figure out a way to configure my server-side backend, written in Golang, to perform all of the neccessary steps in order to send me an e-mail from the front-end (written in &lt;a href=&#34;http://angularjs.org&#34;&gt;AngularJS&lt;/a&gt;).  Looking into it, I don&amp;rsquo;t see too many e-mail sending implementations in Golang available easily online, so I&amp;rsquo;m putting the results of my research out there for all to see.&lt;/p&gt;

&lt;p&gt;{% img /images/golang-gmail/gopher_mail.jpeg A helpful little gopher. %}&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;&lt;code&gt;net/smtp&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;Golang provides a &lt;code&gt;smtp&lt;/code&gt; (&lt;a href=&#34;http://golang.org/pkg/net/smtp/&#34;&gt;Simple Mail Transfer Protocol&lt;/a&gt;) library as part of its &lt;code&gt;net&lt;/code&gt; package.  &lt;code&gt;&amp;quot;net/smtp&amp;quot;&lt;/code&gt; exposes some useful functionality right out of the box.  As it turns out, it&amp;rsquo;s [not too hard]() to connect to [Gmail]() using &lt;code&gt;net/smtp&lt;/code&gt;, which saved me some serious misgivings I was having about setting up and configuring my own mail server (I&amp;rsquo;ve no doubt it could be done, but I was looking for a quick and simple solution).  So I signed up for a &lt;a href=&#34;https://accounts.google.com/SignUp?service=mail&amp;amp;hl=en_us&amp;amp;continue=http%3A%2F%2Fmail.google.com%2Fmail%2F%3Fpc%3Den-ha-na-us-bk&amp;amp;utm_campaign=en&amp;amp;utm_source=en-ha-na-us-bk&amp;amp;utm_medium=ha&#34;&gt;new Gmail account&lt;/a&gt; and connected to that to send e-mails to my primary address from the Check For Broken Links app form.  As it turns out, doing so with &lt;code&gt;&amp;quot;net/smtp&amp;quot;&lt;/code&gt; is fairly straightforward.  You call &lt;code&gt;smtp.PlainAuth&lt;/code&gt; with the proper credentials and domain name, and it returns you back an instance of &lt;code&gt;smtp.Auth&lt;/code&gt; that you can use to send e-mails.  I use a custom-defined &lt;code&gt;struct&lt;/code&gt; called &lt;code&gt;EmailUser&lt;/code&gt; to define the parameters for that call for clarity&amp;rsquo;s sake, and so that I can keep them defined in a configuration file.&lt;/p&gt;

&lt;p&gt;This is an example usage:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type EmailUser struct {
    Username    string
    Password    string
    EmailServer string
    Port        int
}

emailUser := &amp;amp;EmailUser{&#39;yourGmailUsername&#39;, &#39;password&#39;, &#39;smtp.gmail.com&#39;, 587}

auth := smtp.PlainAuth(&amp;quot;&amp;quot;,
    emailUser.Username,
    emailUser.Password,
    emailUser.EmailServer
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Templating Mail&lt;/h1&gt;

&lt;p&gt;Odds are good that you don&amp;rsquo;t want to send identical e-mails all of the time, so I&amp;rsquo;ll walk you through setting up some basic templated e-mails and then show you how to send them using &lt;code&gt;net/smtp&lt;/code&gt; after we&amp;rsquo;ve already connected to Gmail.  When you format an e-mail sent with SMTP correctly, useful information about the sender, subject, and so on will be parsed out of the e-mail&amp;rsquo;s body and interpreted/displayed by the recipients e-mail client in the manner that one would expect.  You can also use more complex template structures to generate e-mails that have more user-specific data, for example if you wanted to send your customers a customized report of their server&amp;rsquo;s bandwidth usage over time via e-mail, or a list of the items they purchased and their invoicing status.&lt;/p&gt;

&lt;p&gt;I use a struct called &lt;code&gt;SmtpTemplateData&lt;/code&gt; to keep track of the basic information for templating the e-mail.  In this case, we know the value of the e-mail body text ahead of time, but we could also run a template for the body template if we wanted to include business-specific logic such as mentioned above.  We import &lt;code&gt;&amp;quot;text/template&amp;quot;&lt;/code&gt; and &lt;code&gt;&amp;quot;bytes&amp;quot;&lt;/code&gt;, then:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type SmtpTemplateData struct {
    From    string
    To      string
    Subject string
    Body    string
}

const emailTemplate = `From: &amp;amp;#123;&amp;amp;#123;.From&amp;amp;#125;&amp;amp;#125;
To: &amp;amp;#123;&amp;amp;#123;.To}&amp;amp;#125;&amp;amp;#125;
Subject: &amp;amp;#123;&amp;amp;#123;.Subject&amp;amp;#125;&amp;amp;#125;

&amp;amp;#123;&amp;amp;#123;.Body&amp;amp;#125;&amp;amp;#125;

Sincerely,

&amp;amp;#123;&amp;amp;#123;.From&amp;amp;#125;&amp;amp;#125;
`
var err error
var doc bytes.Buffer

context := &amp;amp;SmtpTemplateData{
    &amp;quot;SmtpEmailSender&amp;quot;,
    &amp;quot;recipient@domain.com&amp;quot;,
    &amp;quot;This is the e-mail subject line!&amp;quot;,
    &amp;quot;Hello, this is a test e-mail body.&amp;quot;
}
t := template.New(&amp;quot;emailTemplate&amp;quot;)
t, err = t.Parse(emailTemplate)
if err != nil {
    log.Print(&amp;quot;error trying to parse mail template&amp;quot;)
}
err = t.Execute(&amp;amp;doc, context)
if err != nil {
    log.Print(&amp;quot;error trying to execute mail template&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, you can send mail with &lt;code&gt;smtp.SendMail&lt;/code&gt;, passing a list of recipients as well as the &lt;code&gt;bytes.Buffer&lt;/code&gt; buffer for the body of the e-mail:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;err = smtp.SendMail(emailUser.EmailServer+&amp;quot;:&amp;quot;+strconv.Itoa(emailUser.Port), // in our case, &amp;quot;smtp.google.com:587&amp;quot;
    auth,
    emailUser.Username,
    []string{&amp;quot;nathanleclaire@gmail.com&amp;quot;},
    doc.Bytes())
if err != nil {
    log.Print(&amp;quot;ERROR: attempting to send a mail &amp;quot;, err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to send e-mails concurrently, or just not block in a HTTP handler, you can encapsulate the above functionality in a function and invoke it with &lt;code&gt;go sendMail(/* params ... */)&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;net/smtp&amp;quot;&lt;/code&gt; gets the job done, but specifically for the task of sending e-mails from Gmail it takes a little bit of setup.  I may take a whack at making a simple, clean implementation of a library for this purpose (also providing support for boiletplate templating).&lt;/p&gt;

&lt;p&gt;Hope this article has been useful and you have a Merry Christmas.  And as always, stay sassy Internet.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Nathan&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>